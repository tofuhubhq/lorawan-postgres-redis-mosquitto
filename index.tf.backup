terraform {
  required_providers {
    digitalocean = {
      source  = "digitalocean/digitalocean"
      version = "~> 2.0"
    }
  }

  # backend "s3" {
  #   bucket = "your-space-name"     # DigitalOcean Space name
  #   region = "nyc3"                # Space region (e.g., nyc3, sfo2)
  #   key    = "path/to/statefile.tfstate"  # Path within the Space (e.g., `myproject/terraform.tfstate`)
  #   access_key = "your-access-key"  # DigitalOcean access key
  #   secret_key = "your-secret-key"  # DigitalOcean secret key
  #   endpoint = "nyc3.digitaloceanspaces.com"  # Endpoint for DigitalOcean Spaces (nyc3, sfo2, etc.)
  #   acl = "private"               # Make the state file private
  # }
}

# Digital Ocean
variable "do_domain" {
  description = "Digital ocean domain"
  type        = string
  default     = ""
}

variable "do_access_token" {
  description = "Digital ocean access token"
  type        = string
  default     = ""
}

variable "do_project_name" {
  description = "Digital ocean project name"
  type        = string
  default     = ""
}

variable "do_project_description" {
  description = "Digital ocean project description"
  type        = string
  default     = ""
}

variable "do_db_name" {
  description = "Digital ocean database name"
  type        = string
  default     = ""
}

variable "do_db_region" {
  description = "Digital ocean database region"
  type        = string
  default     = ""
}

variable "do_db_engine" {
  description = "Digital ocean database version"
  type        = string
  default     = ""
}

variable "do_db_version" {
  description = "Digital ocean database version"
  type        = string
  default     = ""
}

variable "do_db_size" {
  description = "Digital ocean database size"
  type        = string
  default     = ""
}

variable "do_db_node_count" {
  description = "Digital ocean database node count"
  type        = string
  default     = ""
}

variable "do_droplet_region" {
  description = "Digital ocean droplet region"
  type        = string
  default     = ""
}

variable "do_droplet_size" {
  description = "Digital ocean droplet size"
  type        = string
  default     = ""
}

variable "do_droplet_image" {
  description = "Digital ocean droplet image"
  type        = string
  default     = ""
}

variable "do_droplet_count" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "private_key_path" {
  description = "Path to your private SSH key"
  type        = string
  default     = "~/.ssh/id_rsa"
}

variable "do_mq_region" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_mq_image" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_mq_size" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_mq_name" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_rd_name" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_rd_engine" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_rd_version" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_rd_region" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_rd_size" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

variable "do_rd_node_count" {
  description = "Digital ocean droplet count"
  type        = string
  default     = ""
}

# Obtained through ssh-keygen -lf ~/.ssh/id_rsa.pub
variable "do_ssh_key_name" {
  default = ""
}

# Providers

provider "digitalocean" {
  token = var.do_access_token
}

# This would be needed if the key did not exist.
# resource "digitalocean_ssh_key" "my_key" {
#   name       = "tommaso.girotto91@gmail.com"
#   public_key = file("~/.ssh/id_rsa.pub")  # Adjust path if different
# }

# Since the key already exists, we can just use a key that
data "digitalocean_ssh_key" "my_key" {
  name = var.do_ssh_key_name
}

# Create the domain
resource "digitalocean_domain" "grafana_domain" {
  name = var.do_domain
  # ip   = "203.0.113.10"  # Optional: sets an A record for root domain
}

# # Create the certificate depending on the domain
# resource "digitalocean_certificate" "grafana_cert" {
#   name    = "lorawan-cert"
#   type    = "lets_encrypt"
#   domains = [var.do_domain]  # e.g., "grafana.example.com"
# }

# Create a DigitalOcean project
resource "digitalocean_project" "playground" {
  name        = var.do_project_name
  description = var.do_project_description
  purpose     = "Web Application"
  environment = "Development"
}

# # Assign the domain to the project
# resource "digitalocean_project_resources" "assign_domain" {
#   project = digitalocean_project.playground.id
#   resources = [
#     digitalocean_domain.grafana_domain.urn
#   ]
# }

# Create Postgres cluster
resource "digitalocean_database_cluster" "postgres" {
  name       = var.do_db_name
  engine     = var.do_db_engine
  version    = var.do_db_version
  size       = var.do_db_size
  region     = var.do_db_region
  node_count = var.do_db_node_count
  project_id = digitalocean_project.playground.id  # Reference the project created earlier
}

# Create a mosquitto server
resource "digitalocean_droplet" "mosquitto" {
  name       = var.do_mq_name
  region     = var.do_droplet_region
  size       = var.do_mq_size
  image      = var.do_mq_image
  ssh_keys   = [data.digitalocean_ssh_key.my_key.id]

  connection {
    type        = "ssh"
    user        = "root"
    private_key = file(var.private_key_path)
    host        = self.ipv4_address
  }

  provisioner "remote-exec" {
    inline = [
      "apt-get update",
      "ufw disable || true",
      "apt-get install -y mosquitto mosquitto-clients",
      "systemctl enable mosquitto",
      "systemctl start mosquitto"
    ]
  }
}


# Now that we deployed the database, we can create the string that's going
# to run the docker container that runs grafana
# locals {
#   grafana_command = templatefile("${path.module}/grafana.sh.tpl", {
#     db_host     = digitalocean_database_cluster.postgres.host
#     db_port     = digitalocean_database_cluster.postgres.port
#     db_name     = digitalocean_database_cluster.postgres.database
#     db_user     = digitalocean_database_cluster.postgres.user
#     db_password = digitalocean_database_cluster.postgres.password
#   })
# }

resource "digitalocean_droplet" "lorawan_nodes" {
  count  = var.do_droplet_count
  name   = "lorawan-node-${count.index + 1}"
  region = var.do_droplet_region
  size   = var.do_droplet_size
  image  = var.do_droplet_image
  ssh_keys = [data.digitalocean_ssh_key.my_key.id]

  tags = ["lorawan"]

  connection {
    type        = "ssh"
    user        = "root"
    private_key = file(var.private_key_path)
    host        = self.ipv4_address
  }

  provisioner "file" {
    source      = "docker-compose.yml"
    destination = "/root/docker-compose.yml"
  }

  provisioner "remote-exec" {
    inline = [
      "ufw disable || true",
      "apt-get update -y",
      "apt-get install -y docker.io",
      "curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose",
      "chmod +x /usr/local/bin/docker-compose",
      <<-EOC
        cd /root && docker-compose up --build -d \
      EOC
    ]
  }
}

# Deploy a redis instance
resource "digitalocean_database_cluster" "redis" {
  name       = var.do_rd_name
  engine     = var.do_rd_engine
  version    = var.do_rd_version
  region     = var.do_rd_region
  size       = var.do_rd_size
  node_count = var.do_rd_node_count
}

# # Whitelist traffic to database
# resource "digitalocean_database_firewall" "whitelist_grafana_tag" {
#   cluster_id = digitalocean_database_cluster.postgres.id

#   rule {
#     type  = "tag"
#     value = "lorawan"  # This must match the tag used on your droplets
#   }

#   # Optional: allow your local IP for debugging
#   # rule {
#   #   type  = "ip_addr"
#   #   value = "203.0.113.10"
#   # }
# }


# # === ASSIGN DROPLETS TO PROJECT ===
# # This we need to do since the do provider does not allow to assign a droplet
# # to a project upon creation
# resource "digitalocean_project_resources" "assign_droplets" {
#   project = digitalocean_project.playground.id
#   resources = [
#     for droplet in digitalocean_droplet.lorawan_nodes : droplet.urn
#   ]
# }

# # Creata a load balancer
# # resource "digitalocean_loadbalancer" "grafana_lb" {
# #   name   = "grafana-loadbalancer"
# #   region = var.do_droplet_region

# #   forwarding_rule {
# #     entry_protocol  = "https"
# #     entry_port      = 443
# #     target_protocol = "http"
# #     target_port     = 3000
# #     certificate_name = digitalocean_certificate.grafana_cert.name
# #     tls_passthrough = false #ssl termination
# #   }

# #   healthcheck {
# #     protocol               = "http"
# #     port                   = 3000
# #     path                   = "/login" # Grafana login page
# #     check_interval_seconds = 10
# #     response_timeout_seconds = 5
# #     healthy_threshold      = 5
# #     unhealthy_threshold    = 3
# #   }

# #   droplet_ids = [for d in digitalocean_droplet.grafana_nodes : d.id]

# #   enable_proxy_protocol = false
# # }
